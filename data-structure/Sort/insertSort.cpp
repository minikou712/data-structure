#include <iostream>
using namespace std;

// 插入排序
// 实现思想：将待排序的元素逐个插入到已排序的序列中
void insertSort(int q[], int n)
{
    for (int i = 1; i < n; i++)
    {
        int temp = q[i]; // 保存当前要插入的元素
        int j = i - 1;   // 从已排序部分的最后一个元素开始比较

        // 将大于temp的元素向右移动
        while (j >= 0 && q[j] > temp)
        {
            q[j + 1] = q[j];
            j--;
        }

        // 在正确位置插入temp
        q[j + 1] = temp;
    }
}
// 时间复杂度：O(n^2) 最坏情况：当输入数组是逆序时  最好情况：当输入数组是正序时
// 空间复杂度：O(1)
// 稳定性：稳定



// 希尔排序
//  实现思路：通过将整个待排序序列分割成若干个子序列分别进行插入排序，
//  然后再对整个序列进行一次插入排序，最终达到整体有序的目的。
//  步骤：
//  1. 选择一个增量序列
//  2. 按照增量序列分组，对每个子序列进行插入排序
//  3. 缩小增量，重复步骤2，直到增量为1

void shellSort(int q[], int n)
{
    // 1. 选择一个增量序列
    int gap = n / 2; // 初始增量为数组长度的一半

    while (gap > 0)
    {
        // 2. 按照增量序列分组，对每个子序列进行插入排序
        for (int i = gap; i < n; i++)   
        {
            int temp = q[i];
            int j = i;

            // 对当前子序列进行插入排序
            while (j >= gap && q[j - gap] > temp) // j >= gap，确保 j - gap 不会越界
            {
                q[j] = q[j - gap];
                j -= gap;
            }
            q[j] = temp;
        }

        // 3. 缩小增量，重复步骤2，直到增量为1
        gap /= 2;
    }
}
// 时间复杂度最好情况：O(n log n)  时间复杂度最坏情况：O(n^2) 平均情况：O(n^1.3)
// 空间复杂度：O(1)
//稳定性：不稳定



//gap=2 [8, 3, 5, 4, 7, 6, 1, 2]
// 子序列1: q[0], q[2], q[4], q[6] -> [8, 5, 7, 1]   排序过程 [8,5]->[5,8] i++ [5,8,7]->[5,7,8] i++ [5,7,8,1]->[5,7,1,8]->[5,1,7,8]->[1,5,7,8]
// 子序列2: q[1], q[3], q[5], q[7] -> [3, 4, 6, 2]