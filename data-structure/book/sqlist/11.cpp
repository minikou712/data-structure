#include "sqlist.h"

// 题目11：【2011统考真题】

// 一个长度为L(L≥1)的升序序列S，处在第⌈L/2⌉个位置的数称为S的中位数。
// 例如，若序列S₁=(11, 13, 15, 17, 19)，
// 则S₁的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。
// 例如，若S₂=(2, 4, 6, 8, 20)，则S₁和S₂的中位数是11，
// 现有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，
// 找出两个序列A和B的中位数。

// 要求：
// 给出算法的基本设计思想。
// 根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。
// 说明你所设计算法的时间复杂度和空间复杂度。

// 思路一将两个序列合并成一个序列，然后取中位数
//  时间复杂度O(n)，空间复杂度O(n)
// 合并双指针算法
int M_search(int A[], int B[], int n)
{
    int i = 0, j = 0;
    int C[2 * n];
    int k = 0;
    while (i < n && j < n)
    {
        if (A[i] < B[j])
        {
            C[k++] = A[i];
            i++;
        }
        else
        {
            C[k++] = B[j];
            j++;
        }
    }
    while (i < n)
    {
        C[k++] = A[i];
        i++;
    }
    while (j < n)
    {
        C[k++] = B[j];
        j++;
    }
    return C[n - 1]; // 由于合并后C长度为2n一定为偶数，则第n个位置即中位数，即n-1索引
}

// 法二 时间复杂度log(n)
//  思路二：使用二分查找
//  通过二分查找的方式，找到两个序列的中位数a,b
//  如果a < b，舍弃序列A的前半部分和序列B的后半部分
//  如果a > b，舍弃序列A的后半部分和序列B的前半部分
//  如果a == b，则说明中位数就是a或b

// 基本思想：使用二分查找，每次排除一半元素
int M_search_binary(int A[], int B[], int n)
{
    // 确保A的长度不大于B的长度，简化处理
    if (n == 1)
        return (A[0] + B[0]) / 2;

    int s1 = 0, d1 = n - 1; // A数组的起始和结束位置
    int s2 = 0, d2 = n - 1; // B数组的起始和结束位置
    int m1, m2;             // 两个数组的中点

    while (s1 != d1 || s2 != d2) // 当两个数组的起始和结束位置不相等时
    {
        m1 = (s1 + d1) / 2; // A数组中点
        m2 = (s2 + d2) / 2; // B数组中点

        if (A[m1] == B[m2])
        {
            return A[m1]; // 找到中位数
        }
        else if (A[m1] < B[m2])
        {
            // A[m1]小于B[m2]，排除A的前半部分和B的后半部分
            if ((s1 + d1) % 2 == 0) // A的长度为奇数
            {
                s1 = m1; // 保留中点
                d2 = m2; // 保留中点
            }
            else // A的长度为偶数
            {
                s1 = m1 + 1;
                d2 = m2;
            }
        }
        else // A[m1] > B[m2]
        {
            // A[m1]大于B[m2]，排除A的后半部分和B的前半部分
            if ((s2 + d2) % 2 == 0) // B的长度为奇数
            {
                d1 = m1; // 保留中点
                s2 = m2; // 保留中点
            }
            else // B的长度为偶数
            {
                d1 = m1;
                s2 = m2 + 1;
            }
        }
    }

    return A[s1] < B[s2] ? A[s1] : B[s2]; // 返回较小值
}

