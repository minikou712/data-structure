# 顺序表(SqList)常考知识点总结与代码模板

## 一、顺序表基本结构定义

### 1. 顺序表结构定义
```cpp
typedef struct {
    ElemType *data;   // 存储空间的基地址
    int length;       // 当前表长
    int maxSize;      // 最大存储容量（可选）
} SqList;

// 或者简化版本
typedef struct {
    ElemType data[MaxSize];  // 静态数组
    int length;              // 当前表长
} SqList;
```

## 二、最核心的顺序表思想与方法

### 1. 双指针技术 ⭐⭐⭐⭐⭐
> **顺序表最重要的解题思想**

#### (1) 快慢双指针（元素删除核心思想）
**用途：** 删除特定元素、去重、筛选元素
```cpp
// 删除所有值为x的元素（经典模板）
void deleteX(SqList &L, ElemType x) {
    int k = 0;  // 慢指针，指向下一个保留元素的位置
    for (int i = 0; i < L.length; i++) {  // 快指针遍历
        if (L.data[i] != x) {
            L.data[k] = L.data[i];
            k++;
        }
    }
    L.length = k;  // 更新长度
}

// 删除指定范围内的元素
bool deleteBetween(SqList &L, ElemType s, ElemType t) {
    if (s >= t) return false;
    
    int k = 0;  // 保留元素个数
    for (int i = 0; i < L.length; i++) {
        if (L.data[i] < s || L.data[i] > t) {  // 保留范围外的元素
            L.data[k] = L.data[i];
            k++;
        }
    }
    L.length = k;
    return true;
}
```

#### (2) 有序表去重（双指针经典应用）
```cpp
// 有序表去重
bool deleteDuplicates(SqList &L) {
    if (L.length == 0) return true;
    
    int j = 0;  // 慢指针，指向不重复序列的末尾
    for (int i = 1; i < L.length; i++) {  // 快指针从第二个元素开始
        if (L.data[i] != L.data[j]) {
            j++;
            L.data[j] = L.data[i];
        }
    }
    L.length = j + 1;
    return true;
}
```

### 2. 三指针技术 ⭐⭐⭐⭐
**用途：** 多个有序数组的操作

#### (1) 三个有序数组求交集
```cpp
void findCommonElements(int A[], int B[], int C[], int n) {
    int i = 0, j = 0, k = 0;
    
    while (i < n && j < n && k < n) {
        int maxVal = max(A[i], max(B[j], C[k]));
        
        if (A[i] == B[j] && B[j] == C[k]) {
            cout << A[i] << " ";  // 输出交集元素
            i++; j++; k++;
        } else {
            // 让较小的指针向前移动
            if (A[i] < maxVal) i++;
            else if (B[j] < maxVal) j++;
            else k++;
        }
    }
}
```

#### (2) 三元组最小距离问题
```cpp
int minDistance(int S1[], int S2[], int S3[], int n1, int n2, int n3) {
    // 确保数组有序
    sort(S1, S1 + n1);
    sort(S2, S2 + n2);
    sort(S3, S3 + n3);
    
    int i = 0, j = 0, k = 0;
    int minDist = INT_MAX;
    
    while (i < n1 && j < n2 && k < n3) {
        int a = S1[i], b = S2[j], c = S3[k];
        int dist = abs(a - b) + abs(b - c) + abs(c - a);
        
        minDist = min(minDist, dist);
        
        // 移动最小值对应的指针
        int minVal = min(a, min(b, c));
        if (minVal == a) i++;
        else if (minVal == b) j++;
        else k++;
    }
    
    return minDist;
}
```

### 3. 数组逆置技术 ⭐⭐⭐⭐⭐
> **循环移位和交换的核心技术**

#### (1) 基本逆置函数
```cpp
void reverse(int A[], int start, int end) {
    while (start < end) {
        swap(A[start], A[end]);
        start++;
        end--;
    }
}
```

#### (2) 循环左移p位（三次逆置法）
```cpp
void rotateLeft(int A[], int n, int p) {
    p = p % n;  // 处理p>=n的情况
    reverse(A, 0, n - 1);     // 整体逆置
    reverse(A, 0, p - 1);     // 前p个逆置
    reverse(A, p, n - 1);     // 后n-p个逆置
}
```

#### (3) 数组两部分交换位置
```cpp
// 将A[0..m-1]和A[m..m+n-1]交换位置
void exchange(int A[], int m, int n) {
    reverse(A, 0, m + n - 1);  // 整体逆置
    reverse(A, 0, n - 1);      // 前n个逆置  
    reverse(A, n, m + n - 1);  // 后m个逆置
}
```

### 4. 归并技术 ⭐⭐⭐⭐
**用途：** 合并有序数组

```cpp
bool merge(SqList &La, SqList &Lb, SqList &Lc) {
    int i = 0, j = 0, k = 0;
    
    // 归并过程
    while (i < La.length && j < Lb.length) {
        if (La.data[i] <= Lb.data[j]) {
            Lc.data[k++] = La.data[i++];
        } else {
            Lc.data[k++] = Lb.data[j++];
        }
    }
    
    // 处理剩余元素
    while (i < La.length) Lc.data[k++] = La.data[i++];
    while (j < Lb.length) Lc.data[k++] = Lb.data[j++];
    
    Lc.length = k;
    return true;
}
```

### 5. 二分查找技术 ⭐⭐⭐⭐
**用途：** 有序数组的快速查找

```cpp
// 标准二分查找
int binarySearch(int A[], int n, int x) {
    int left = 0, right = n - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (A[mid] == x) return mid;
        else if (A[mid] < x) left = mid + 1;
        else right = mid - 1;
    }
    
    return -1;  // 未找到
}

// 查找并插入（保持有序）
void searchAndInsert(int A[], int &n, int x) {
    int pos = binarySearch(A, n, x);
    
    if (pos != -1) {
        // 找到x，与后继交换
        if (pos < n - 1) {
            swap(A[pos], A[pos + 1]);
        }
    } else {
        // 未找到，插入保持有序
        int i = n - 1;
        while (i >= 0 && A[i] > x) {
            A[i + 1] = A[i];
            i--;
        }
        A[i + 1] = x;
        n++;
    }
}
```

### 6. 摩尔投票算法 ⭐⭐⭐⭐
**用途：** 寻找主元素（出现次数>n/2）

```cpp
int majorityElement(int A[], int n) {
    int candidate = -1, count = 0;
    
    // 第一轮：找候选元素
    for (int i = 0; i < n; i++) {
        if (count == 0) {
            candidate = A[i];
            count = 1;
        } else if (A[i] == candidate) {
            count++;
        } else {
            count--;
        }
    }
    
    // 第二轮：验证候选元素
    count = 0;
    for (int i = 0; i < n; i++) {
        if (A[i] == candidate) count++;
    }
    
    return (count > n / 2) ? candidate : -1;
}
```

### 7. 哈希思想（数组模拟） ⭐⭐⭐
**用途：** 统计、查找、去重

```cpp
// 寻找未出现的最小正整数
int findFirstMissingPositive(int A[], int n) {
    bool exists[n + 1] = {false};  // 哈希表
    
    // 标记存在的正整数
    for (int i = 0; i < n; i++) {
        if (A[i] > 0 && A[i] <= n) {
            exists[A[i]] = true;
        }
    }
    
    // 寻找第一个未出现的正整数
    for (int i = 1; i <= n; i++) {
        if (!exists[i]) return i;
    }
    
    return n + 1;
}
```

## 三、最容易考的题型

### 1. 基础操作题 ⭐⭐⭐⭐⭐
- 删除最小元素
- 删除特定值的所有元素
- 删除指定范围内的元素
- 数组逆置

### 2. 双指针应用题 ⭐⭐⭐⭐⭐
- 有序数组去重
- 元素删除与保留
- 数组分割与重排

### 3. 数组旋转题 ⭐⭐⭐⭐⭐
- 循环左移/右移
- 数组部分交换
- 三次逆置法应用

### 4. 有序数组操作题 ⭐⭐⭐⭐⭐
- 两个有序数组合并
- 二分查找及其变种
- 寻找两个有序数组的中位数

### 5. 多数组问题 ⭐⭐⭐⭐
- 三个有序数组求交集
- 三元组最小距离
- 多指针同步遍历

### 6. 统计类问题 ⭐⭐⭐⭐
- 主元素查找（摩尔投票）
- 缺失元素查找
- 频次统计

### 7. 统考真题类型 ⭐⭐⭐⭐⭐
- 2010年：循环移位
- 2011年：两个有序数组中位数
- 2013年：主元素
- 2018年：最小正整数
- 2020年：三元组距离

## 四、核心代码模板

### 1. 标准遍历模板
```cpp
// 基本遍历
for (int i = 0; i < L.length; i++) {
    // 处理L.data[i]
}
```

### 2. 双指针删除模板
```cpp
// 元素删除通用模板
int k = 0;  // 慢指针
for (int i = 0; i < L.length; i++) {  // 快指针
    if (/* 保留条件 */) {
        L.data[k] = L.data[i];
        k++;
    }
}
L.length = k;
```

### 3. 三指针遍历模板
```cpp
// 三个数组同步遍历
int i = 0, j = 0, k = 0;
while (i < n1 && j < n2 && k < n3) {
    // 处理当前元素
    // 根据条件移动相应指针
}
```

### 4. 逆置操作模板
```cpp
// 数组逆置通用模板
void reverse(int A[], int start, int end) {
    while (start < end) {
        swap(A[start], A[end]);
        start++;
        end--;
    }
}
```

### 5. 二分查找模板
```cpp
// 二分查找通用模板
int binarySearch(int A[], int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (A[mid] == target) return mid;
        else if (A[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

### 6. 归并操作模板
```cpp
// 两个有序数组归并
void merge(int A[], int m, int B[], int n, int C[]) {
    int i = 0, j = 0, k = 0;
    while (i < m && j < n) {
        if (A[i] <= B[j]) C[k++] = A[i++];
        else C[k++] = B[j++];
    }
    while (i < m) C[k++] = A[i++];
    while (j < n) C[k++] = B[j++];
}
```

## 五、时空复杂度优化技巧

### 1. 时间复杂度优化
- **O(n²) → O(n)**：使用双指针代替嵌套循环
- **O(n) → O(log n)**：有序数组使用二分查找
- **一次遍历解决**：合理利用双指针技术

### 2. 空间复杂度优化
- **原地操作**：避免额外数组，直接在原数组上修改
- **三次逆置**：O(1)空间实现数组旋转
- **数组模拟哈希**：在数据范围有限时替代哈希表

### 3. 算法选择策略
- **有序数组**：优先考虑二分查找、双指针
- **无序数组**：考虑排序+双指针，或哈希思想
- **多个数组**：考虑多指针同步遍历
- **旋转操作**：三次逆置法是最优解

## 六、考试重点提醒

1. **双指针技术是重中之重**：快慢指针解决删除、去重问题
2. **三次逆置法必须掌握**：数组旋转的标准解法
3. **二分查找及其变种**：有序数组操作的核心
4. **多指针协同**：处理多个数组的标准思路
5. **时空复杂度分析**：要求能准确分析算法复杂度
6. **边界条件处理**：空数组、单元素等特殊情况
7. **统考真题规律**：重点关注2010-2020年统考题型

## 七、常见错误避免

1. **指针越界**：注意循环边界条件
2. **长度更新**：删除操作后要更新数组长度
3. **逆置操作**：注意start < end的条件
4. **二分查找**：防止整数溢出，使用mid = left + (right-left)/2
5. **多指针移动**：确保每次循环都有指针移动，避免死循环

> **记住**：顺序表题目的核心在于**高效的遍历和原地操作**，掌握双指针、逆置、二分等核心技术，大部分问题都能迎刃而解！
