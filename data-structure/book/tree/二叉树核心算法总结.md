# 二叉树核心算法总结与模板

## 一、17个核心算法总结

### 1. 二叉树基础性质分析（题目1-2）
- **核心思想**：理解先序、中序、后序遍历的性质
- **关键点**：
  - 先序与后序相反 → 单链结构
  - 先序与后序相同 → 只有根节点

### 2. 二叉树高度计算（题目3）
- **核心思想**：层序遍历统计层数
- **算法复杂度**：O(n)时间，O(w)空间（w为最大宽度）

### 3. 完全二叉树判断（题目4）
- **核心思想**：层序遍历中一旦出现空节点，后续不能再有非空节点
- **关键技巧**：使用标志位记录第一个缺失子节点

### 4. 节点统计类算法（题目5、11）
- **双分支节点统计**：递归判断左右子树都存在
- **二叉树宽度**：层序遍历中每层节点数的最大值

### 5. 二叉树结构变换（题目6、13）
- **左右子树交换**：递归交换每个节点的左右指针
- **叶节点链表化**：DFS遍历，用右指针连接叶节点

### 6. 遍历序列处理（题目7、12）
- **第k个先序节点**：计数器配合递归遍历
- **先序转后序**：利用满二叉树左右子树节点数相等的性质

### 7. 节点删除操作（题目8）
- **核心思想**：先判断再删除，避免访问已删除节点
- **技巧**：使用引用参数修改指针

### 8. 路径查找算法（题目9）
- **祖先查找**：递归回溯，找到目标后打印路径
- **技巧**：利用递归栈保存路径信息

### 9. 最近公共祖先（题目10）
- **核心思想**：分治算法，在左右子树中分别查找
- **关键判断**：两个节点分别在左右子树时，当前节点为LCA

### 10. 二叉树相似性判断（题目14）
- **核心思想**：结构递归比较，不关心节点值

### 11. 带权路径长度（题目15 - 2014统考真题）
- **核心思想**：深度优先搜索，记录深度，叶节点累加权值×深度
- **应用场景**：哈夫曼树、最优编码

### 12. 表达式树转中缀表达式（题目16 - 2017统考真题）
- **核心思想**：中序遍历+括号，叶节点直接输出，内部节点加括号
- **输出格式**：(左子树)(操作符)(右子树)

### 13. 二叉搜索树判断（题目17 - 2022统考真题）
- **核心思想**：递归范围约束，每个节点必须在特定数值区间内
- **优化方法**：使用pmax/pmin数组预处理约束

## 二、核心算法模板

### 1. 递归遍历通用模板
```cpp
void traverse(TreeNode* root) {
    if (root == nullptr) return;  // 递归终止条件
    
    // 先序位置：处理当前节点
    process(root);
    
    traverse(root->left);   // 递归左子树
    traverse(root->right);  // 递归右子树
    
    // 后序位置：处理当前节点
}
```

### 2. 层序遍历模板
```cpp
void levelOrder(TreeNode* root) {
    if (root == nullptr) return;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();  // 当前层节点数
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            // 处理当前节点
            process(node);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        // 一层处理完毕
    }
}
```

### 3. 二叉搜索树验证模板
```cpp
bool isValidBST(TreeNode* root, int minVal, int maxVal) {
    if (root == nullptr) return true;
    
    if (root->val <= minVal || root->val >= maxVal) 
        return false;
    
    return isValidBST(root->left, minVal, root->val) &&
           isValidBST(root->right, root->val, maxVal);
}
```

### 4. 路径查找模板
```cpp
bool findPath(TreeNode* root, int target, vector<int>& path) {
    if (root == nullptr) return false;
    
    path.push_back(root->val);
    
    if (root->val == target) return true;
    
    if (findPath(root->left, target, path) || 
        findPath(root->right, target, path)) {
        return true;
    }
    
    path.pop_back();  // 回溯
    return false;
}
```

### 5. 最近公共祖先模板
```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr || root == p || root == q) 
        return root;
    
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    
    if (left != nullptr && right != nullptr) 
        return root;
    
    return left != nullptr ? left : right;
}
```

## 三、基于真题15-17的未来考点预测与算法模板

### 预测考点1：树的度量与计算类
**基于题目15（WPL计算）**，可能考查：
- 树的直径计算
- 节点间最大距离
- 树的重心查找

**通用模板**：
```cpp
// 树的度量计算模板
int calculateTreeMetric(TreeNode* root, int& globalMax) {
    if (root == nullptr) return 0;
    
    int leftDepth = calculateTreeMetric(root->left, globalMax);
    int rightDepth = calculateTreeMetric(root->right, globalMax);
    
    // 更新全局最优值
    globalMax = max(globalMax, leftDepth + rightDepth);
    
    return max(leftDepth, rightDepth) + 1;
}
```

### 预测考点2：表达式处理与转换类
**基于题目16（表达式树转中缀）**，可能考查：
- 中缀转后缀表达式
- 表达式求值
- 表达式树的构建

**通用模板**：
```cpp
// 表达式处理模板
void processExpression(TreeNode* root, string& result) {
    if (root == nullptr) return;
    
    if (isLeaf(root)) {
        result += root->data;
        return;
    }
    
    result += "(";
    processExpression(root->left, result);
    result += root->data;
    processExpression(root->right, result);
    result += ")";
}
```

### 预测考点3：特殊二叉树判断与验证类
**基于题目17（BST判断）**，可能考查：
- 平衡二叉树判断
- 完全二叉树验证
- 镜像二叉树判断

**通用模板**：
```cpp
// 树属性验证模板
bool validateTreeProperty(TreeNode* root, 参数列表) {
    if (root == nullptr) return true;  // 空树情况
    
    // 检查当前节点是否满足属性
    if (!checkCurrentNode(root, 参数列表)) 
        return false;
    
    // 递归检查子树
    return validateTreeProperty(root->left, 更新后参数) &&
           validateTreeProperty(root->right, 更新后参数);
}
```

### 预测考点4：复杂遍历与序列重建
**综合15-17题的复杂度**，可能考查：
- 根据多种遍历序列重建二叉树
- 序列化与反序列化
- 特殊约束下的遍历

**通用模板**：
```cpp
// 序列重建模板
TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd,
                   vector<int>& inorder, int inStart, int inEnd) {
    if (preStart > preEnd) return nullptr;
    
    TreeNode* root = new TreeNode(preorder[preStart]);
    int rootIndex = findIndex(inorder, root->val);
    
    int leftSize = rootIndex - inStart;
    
    root->left = buildTree(preorder, preStart + 1, preStart + leftSize,
                          inorder, inStart, rootIndex - 1);
    root->right = buildTree(preorder, preStart + leftSize + 1, preEnd,
                           inorder, rootIndex + 1, inEnd);
    
    return root;
}
```

## 四、解题技巧总结

### 1. 选择递归还是迭代
- **递归优势**：代码简洁，逻辑清晰
- **迭代优势**：避免栈溢出，空间控制更好
- **选择原则**：简单问题用递归，复杂遍历用迭代

### 2. 空间复杂度优化
- 使用数组模拟队列/栈，避免STL开销
- 利用现有指针域，减少额外空间
- 原地算法，如Morris遍历

### 3. 边界条件处理
- 空树处理：return 0/nullptr/false
- 单节点处理：特殊情况单独考虑
- 叶节点判断：left和right都为nullptr

### 4. 考试应对策略
- **理解题意**：仔细分析输入输出格式
- **选择合适数据结构**：根据题目要求选择存储方式
- **考虑时间复杂度**：优先O(n)解法，避免O(n²)
- **编写测试用例**：验证边界情况和普通情况

## 五、重点掌握算法

根据统考真题趋势，重点掌握：

1. **二叉搜索树相关**（出现频率高）
2. **完全二叉树判断**（基础且实用）
3. **表达式树处理**（综合性强）
4. **路径计算问题**（WPL、直径等）
5. **树的遍历变形**（非递归、特殊顺序等）

**备考建议**：
- 熟练掌握递归和层序遍历两种基本方法
- 重点练习BST相关算法
- 注意边界条件的处理
- 多做真题，理解出题规律
