# 链表常考知识点总结与代码模板

## 一、链表基本结构定义

### 1. 单链表节点定义
```cpp
typedef struct Lnode {
    ElemType data;    // 数据域
    Lnode *next;      // 指针域
} Lnode, *LinkList;
```

### 2. 双链表节点定义
```cpp
typedef struct Lnode {
    ElemType data;    // 数据域
    Lnode *next;      // 后继指针
    Lnode *prior;     // 前驱指针
} Lnode, *LinkList;
```

## 二、最常用的链表思想与方法

### 1. 双指针技术 ⭐⭐⭐⭐⭐
> **最重要的链表解题思想**

#### (1) 快慢指针（Floyd算法）
**用途：** 检测环、寻找中点、查找倒数第k个节点
```cpp
// 检测链表是否有环
bool hasCycle(ListNode* head) {
    if (!head || !head->next) return false;
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast && fast->next) {
        slow = slow->next;          // 慢指针走1步
        fast = fast->next->next;    // 快指针走2步
        
        if (slow == fast) {         // 相遇说明有环
            return true;
        }
    }
    return false;
}

// 寻找链表中点
ListNode* findMiddle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;  // slow指向中点
}
```

#### (2) 前后指针
**用途：** 删除倒数第n个节点、寻找倒数第k个节点
```cpp
// 删除倒数第n个节点
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    
    ListNode* first = dummy;
    ListNode* second = dummy;
    
    // first先走n+1步
    for (int i = 0; i <= n; i++) {
        first = first->next;
    }
    
    // 同时移动直到first到末尾
    while (first) {
        first = first->next;
        second = second->next;
    }
    
    // 删除second的下一个节点
    ListNode* nodeToDelete = second->next;
    second->next = second->next->next;
    delete nodeToDelete;
    
    return dummy->next;
}
```

#### (3) 长度差指针
**用途：** 寻找两个链表的交点
```cpp
// 寻找两个链表的交点
ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    // 计算两个链表的长度
    int lenA = getLength(headA);
    int lenB = getLength(headB);
    
    // 让长链表先走差值步
    if (lenA > lenB) {
        for (int i = 0; i < lenA - lenB; i++) {
            headA = headA->next;
        }
    } else {
        for (int i = 0; i < lenB - lenA; i++) {
            headB = headB->next;
        }
    }
    
    // 同时移动寻找交点
    while (headA && headB) {
        if (headA == headB) return headA;
        headA = headA->next;
        headB = headB->next;
    }
    return nullptr;
}
```

### 2. 链表反转技术 ⭐⭐⭐⭐⭐
> **第二重要的技术，面试必考**

#### (1) 迭代反转（三指针法）
```cpp
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* next = nullptr;
    
    while (curr) {
        next = curr->next;    // 保存下一个节点
        curr->next = prev;    // 反转当前链接
        prev = curr;          // 移动prev
        curr = next;          // 移动curr
    }
    return prev;
}
```

#### (2) 头插法反转
```cpp
void reverseListByHeadInsert(LinkList &L) {
    Lnode* p = L->next;
    L->next = nullptr;
    
    while (p) {
        Lnode* r = p->next;
        p->next = L->next;  // 头插法
        L->next = p;
        p = r;
    }
}
```

### 3. 前驱指针技术 ⭐⭐⭐⭐
> **删除操作的核心技术**

#### 删除特定值的所有节点
```cpp
void deleteX(LinkList &L, ElemType x) {
    Lnode* p = L->next;  // 当前节点
    Lnode* q = L;        // 前驱节点
    
    while (p) {
        if (p->data == x) {
            q->next = p->next;
            delete p;
            p = q->next;
        } else {
            q = p;
            p = p->next;
        }
    }
}
```

### 4. 双链表操作 ⭐⭐⭐
```cpp
// 双链表对称性检查
bool isSymmetric(LinkList L) {
    if (L->next == L) return true;
    
    Lnode* left = L->next;    // 从头开始
    Lnode* right = L->prior;  // 从尾开始
    
    while (left != right && left->prior != right) {
        if (left->data != right->data) return false;
        left = left->next;
        right = right->prior;
    }
    return true;
}
```

### 5. 归并操作 ⭐⭐⭐⭐
```cpp
// 合并两个有序链表的公共元素
void mergeCommon(LinkList A, LinkList B, LinkList &C) {
    Lnode* pa = A->next;
    Lnode* pb = B->next;
    Lnode* tail = C;
    
    while (pa && pb) {
        if (pa->data == pb->data) {
            tail->next = pa;
            tail = pa;
            pa = pa->next;
            pb = pb->next;
        } else if (pa->data < pb->data) {
            pa = pa->next;
        } else {
            pb = pb->next;
        }
    }
    tail->next = nullptr;
}
```

## 三、最容易考的题型

### 1. 基础操作题 ⭐⭐⭐⭐⭐
- 删除特定值的节点
- 删除最小值节点
- 删除重复元素
- 在指定位置插入/删除节点

### 2. 链表反转题 ⭐⭐⭐⭐⭐
- 整个链表反转
- 反转部分链表
- k个一组反转链表

### 3. 双指针应用题 ⭐⭐⭐⭐⭐
- 快慢指针检测环
- 寻找链表中点
- 删除倒数第n个节点
- 寻找两个链表的交点

### 4. 链表重排题 ⭐⭐⭐⭐
- 奇偶位置重排
- 按特定模式重排 (a1,an,a2,an-1,...)
- 分离奇偶节点

### 5. 链表合并题 ⭐⭐⭐⭐
- 合并两个有序链表
- 求两个链表的交集/并集
- 判断一个链表是否为另一个的子序列

### 6. 循环链表操作 ⭐⭐⭐
- 循环链表连接
- 约瑟夫环问题
- 循环链表检测

### 7. 双链表操作 ⭐⭐⭐
- 双链表对称性检查
- 双链表排序
- LRU缓存实现

## 四、核心代码模板

### 1. 标准遍历模板
```cpp
// 基本遍历
Lnode* p = L->next;  // 跳过头节点
while (p) {
    // 处理p->data
    p = p->next;
}
```

### 2. 删除操作模板
```cpp
// 删除操作（需要前驱指针）
Lnode* p = L->next;  // 当前节点
Lnode* q = L;        // 前驱节点

while (p) {
    if (/* 删除条件 */) {
        q->next = p->next;
        delete p;
        p = q->next;
    } else {
        q = p;
        p = p->next;
    }
}
```

### 3. 头插法模板
```cpp
// 头插法建立链表
void headInsert(LinkList &L, ElemType x) {
    Lnode* newNode = new Lnode;
    newNode->data = x;
    newNode->next = L->next;
    L->next = newNode;
}
```

### 4. 尾插法模板
```cpp
// 尾插法建立链表
void tailInsert(LinkList &L, ElemType x) {
    Lnode* newNode = new Lnode;
    newNode->data = x;
    newNode->next = nullptr;
    
    // 找到尾节点
    Lnode* tail = L;
    while (tail->next) {
        tail = tail->next;
    }
    tail->next = newNode;
}
```

### 5. 链表初始化模板
```cpp
// 初始化带头节点的链表
LinkList initList() {
    LinkList L = new Lnode;
    L->next = nullptr;
    return L;
}
```

## 五、解题技巧总结

### 1. 时间复杂度优化
- 一次遍历解决问题（双指针）
- 避免多次遍历
- 合理利用额外空间

### 2. 空间复杂度优化
- 原地操作，避免额外数组
- 利用现有指针域
- 头插法/尾插法的灵活运用

### 3. 边界条件处理
- 空链表
- 只有一个节点
- 头节点和尾节点的特殊处理

### 4. 常见错误避免
- 忘记更新前驱指针
- 指针悬空问题
- 内存泄漏
- 循环链表的无限循环

## 六、考试重点提醒

1. **基础操作必须熟练**：插入、删除、遍历
2. **双指针技术是重中之重**：快慢指针、前后指针
3. **链表反转几乎必考**：迭代和递归两种方法都要会
4. **时空复杂度分析**：要能准确分析算法复杂度
5. **边界条件处理**：空链表、单节点等特殊情况
6. **代码规范性**：注释清楚、变量命名规范

> **记住**：链表题目的核心在于**指针的灵活运用**，多练习指针操作，理解每一步指针变化的含义！
